"""Tests for toolpath endpoints."""

import pytest


@pytest.mark.unit
class TestGetToolpath:
    def test_get_existing_toolpath(self, client, seeded_toolpath):
        """Seeded toolpath should be retrievable via the state fallback or service."""
        from backend.server import state

        # The toolpath is stored in state.toolpaths — the endpoint checks
        # state.toolpath_service first, then falls back to state.toolpaths.
        # With the real service, get_toolpath may not find our seeded data
        # because it uses its own storage. So we check both cases.
        response = client.get(f"/api/toolpath/{seeded_toolpath}")
        if state.toolpath_service:
            # Service may or may not find it — depends on internal storage
            # If service returns None, endpoint falls back to state.toolpaths
            assert response.status_code in (200, 404)
        else:
            assert response.status_code == 200
            assert response.json()["data"]["id"] == seeded_toolpath

    def test_get_nonexistent_toolpath(self, client):
        response = client.get("/api/toolpath/does_not_exist_xyz")
        assert response.status_code == 404


@pytest.mark.unit
class TestToolpathGenerate:
    def test_generate_with_nonexistent_file(self, client):
        """Generate with a non-existent file path: 400 (service) or 200 (mock)."""
        response = client.post(
            "/api/toolpath/generate",
            json={"geometryPath": "/tmp/nonexistent_test_geometry.stl"},
        )
        # With real toolpath_service: 400 (file not found / processing error)
        # Without service: 200 (mock response)
        assert response.status_code in (200, 400)

    def test_generate_returns_valid_structure(self, client):
        """Even on error, response should be well-formed JSON."""
        response = client.post(
            "/api/toolpath/generate",
            json={"geometryPath": "/tmp/nonexistent.stl"},
        )
        body = response.json()
        # Should always have either 'data' or 'error'
        assert "data" in body or "error" in body


@pytest.mark.unit
class TestToolpathExportGcode:
    def test_export_gcode_success(self, client, seeded_toolpath):
        response = client.post(
            "/api/toolpath/export-gcode",
            json={"toolpathId": seeded_toolpath},
        )
        assert response.status_code == 200
        data = response.json()["data"]
        assert "gcodeContent" in data
        assert "gcodeFile" in data
        assert data["lines"] > 0
        assert "; Generated by OpenAxis" in data["gcodeContent"]

    def test_export_gcode_nonexistent_toolpath(self, client):
        response = client.post(
            "/api/toolpath/export-gcode",
            json={"toolpathId": "no_such_tp"},
        )
        assert response.status_code == 404


@pytest.mark.unit
class TestToolpathModify:
    def test_modify_nonexistent_toolpath(self, client):
        response = client.post(
            "/api/toolpath/nonexistent/modify",
            json={
                "toolpathId": "nonexistent",
                "action": "speed_override",
                "segmentIndices": [0],
                "value": 500.0,
            },
        )
        assert response.status_code == 404

    def test_modify_speed_override(self, client, seeded_toolpath):
        """Speed override on a seeded toolpath."""
        from backend.server import state

        response = client.post(
            f"/api/toolpath/{seeded_toolpath}/modify",
            json={
                "toolpathId": seeded_toolpath,
                "action": "speed_override",
                "segmentIndices": [0],
                "value": 500.0,
            },
        )
        if state.toolpath_editor_service:
            assert response.status_code == 200
        else:
            assert response.status_code == 503
