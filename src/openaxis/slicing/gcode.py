"""
G-code generation for additive manufacturing processes.

This module converts toolpaths into G-code for various manufacturing
processes including WAAM, FDM, and pellet extrusion.
"""

from dataclasses import dataclass
from enum import Enum
from pathlib import Path
from typing import List, Optional, TextIO

from openaxis.slicing.toolpath import Toolpath, ToolpathSegment, ToolpathType


class GCodeFlavor(Enum):
    """G-code flavor/dialect."""

    MARLIN = "marlin"  # Marlin firmware (FDM)
    REPRAP = "reprap"  # RepRap firmware
    KUKA = "kuka"  # KUKA robot format
    ABB = "abb"  # ABB robot format
    FANUC = "fanuc"  # Fanuc robot format
    GENERIC = "generic"  # Generic G-code


@dataclass
class GCodeConfig:
    """
    Configuration for G-code generation.

    Attributes:
        flavor: G-code dialect to generate
        use_relative_extrusion: Use relative E values
        use_relative_positioning: Use relative XYZ positioning
        feedrate_multiplier: Global feedrate multiplier
        extrusion_multiplier: Global extrusion multiplier
        retract_distance: Retraction distance (mm)
        retract_speed: Retraction speed (mm/s)
        z_hop_height: Z-hop height for travel moves (mm)
        start_gcode: Custom start G-code
        end_gcode: Custom end G-code
        enable_fans: Enable cooling fans
        fan_speed: Fan speed (0-255)
    """

    flavor: GCodeFlavor = GCodeFlavor.GENERIC
    use_relative_extrusion: bool = False
    use_relative_positioning: bool = False
    feedrate_multiplier: float = 1.0
    extrusion_multiplier: float = 1.0
    retract_distance: float = 2.0
    retract_speed: float = 40.0
    z_hop_height: float = 0.5
    start_gcode: str = ""
    end_gcode: str = ""
    enable_fans: bool = False
    fan_speed: int = 255


class GCodeGenerator:
    """
    Generates G-code from toolpaths.

    Converts toolpath segments into machine-readable G-code commands
    for various manufacturing processes.
    """

    def __init__(self, config: Optional[GCodeConfig] = None):
        """
        Initialize G-code generator.

        Args:
            config: G-code generation configuration
        """
        self.config = config or GCodeConfig()
        self.current_position = [0.0, 0.0, 0.0]  # X, Y, Z
        self.current_extrusion = 0.0  # E axis position
        self.current_feedrate = 0.0

    def generate(self, toolpath: Toolpath, output_path: Optional[Path] = None) -> str:
        """
        Generate G-code from a toolpath.

        Args:
            toolpath: Toolpath to convert
            output_path: Optional file path to write G-code to

        Returns:
            Generated G-code as string
        """
        gcode_lines = []

        # Add header
        gcode_lines.extend(self._generate_header(toolpath))

        # Add start G-code
        if self.config.start_gcode:
            gcode_lines.append("; Custom start G-code")
            gcode_lines.append(self.config.start_gcode)

        # Process each segment
        for segment in toolpath.segments:
            segment_gcode = self._generate_segment(segment, toolpath.layer_height)
            gcode_lines.extend(segment_gcode)

        # Add end G-code
        if self.config.end_gcode:
            gcode_lines.append("; Custom end G-code")
            gcode_lines.append(self.config.end_gcode)

        # Add footer
        gcode_lines.extend(self._generate_footer(toolpath))

        # Join into single string
        gcode = "\n".join(gcode_lines)

        # Write to file if requested
        if output_path:
            output_path.write_text(gcode, encoding="utf-8")

        return gcode

    def _generate_header(self, toolpath: Toolpath) -> List[str]:
        """Generate G-code header with metadata."""
        lines = [
            "; Generated by OpenAxis",
            f"; Process: {toolpath.process_type}",
            f"; Material: {toolpath.material}",
            f"; Total layers: {toolpath.total_layers}",
            f"; Layer height: {toolpath.layer_height} mm",
            f"; Total length: {toolpath.get_total_length():.2f} mm",
            f"; Estimated time: {toolpath.get_build_time_estimate():.1f} seconds",
            ";",
            "; Initialization",
            "G90  ; Absolute positioning" if not self.config.use_relative_positioning else "G91  ; Relative positioning",
            "M82  ; Absolute extrusion" if not self.config.use_relative_extrusion else "M83  ; Relative extrusion",
            "G28  ; Home all axes",
            "G92 E0  ; Reset extruder position",
        ]

        if self.config.enable_fans:
            lines.append(f"M106 S{self.config.fan_speed}  ; Set fan speed")
        else:
            lines.append("M107  ; Turn off fans")

        lines.append("")
        return lines

    def _generate_footer(self, toolpath: Toolpath) -> List[str]:
        """Generate G-code footer."""
        return [
            "",
            "; End of print",
            "M104 S0  ; Turn off hotend",
            "M140 S0  ; Turn off bed",
            "M107  ; Turn off fans",
            "G91  ; Relative positioning",
            "G1 Z10 F1000  ; Raise Z",
            "G90  ; Absolute positioning",
            "G28 X Y  ; Home X and Y",
            "M84  ; Disable motors",
            "; Print complete!",
        ]

    def _generate_segment(self, segment: ToolpathSegment, layer_height: float) -> List[str]:
        """
        Generate G-code for a single toolpath segment.

        Args:
            segment: Toolpath segment to convert
            layer_height: Layer height for extrusion calculations

        Returns:
            List of G-code lines
        """
        lines = []

        # Add comment for segment type
        lines.append(f"; {segment.type.value.upper()} - Layer {segment.layer_index}")

        # Handle travel moves (non-extrusion)
        if segment.type == ToolpathType.TRAVEL:
            # Retract
            lines.append(self._retract())

            # Z-hop if enabled
            if self.config.z_hop_height > 0:
                lines.append(self._move_z(self.current_position[2] + self.config.z_hop_height, rapid=True))

            # Move to start point
            if segment.points:
                start = segment.points[0]
                lines.append(self._move(start.x, start.y, start.z, rapid=True))

            # Undo Z-hop
            if self.config.z_hop_height > 0 and segment.points:
                lines.append(self._move_z(segment.points[0].z, rapid=True))

            # Unretract
            lines.append(self._unretract())

            return lines

        # For extrusion moves
        if not segment.points:
            return lines

        # Set temperature if specified
        if segment.temperature > 0:
            lines.append(f"M109 S{segment.temperature:.0f}  ; Set and wait for temperature")

        # Calculate feedrate
        feedrate = segment.speed * 60 * self.config.feedrate_multiplier  # mm/s to mm/min

        # Move through all points
        for i, point in enumerate(segment.points):
            if i == 0:
                # First point - rapid move to position
                lines.append(self._move(point.x, point.y, point.z, rapid=True))
            else:
                # Extrusion move
                prev_point = segment.points[i - 1]

                # Calculate extrusion amount
                distance = (
                    (point.x - prev_point.x) ** 2
                    + (point.y - prev_point.y) ** 2
                    + (point.z - prev_point.z) ** 2
                ) ** 0.5

                extrusion = (
                    distance
                    * segment.extrusion_width
                    * layer_height
                    * segment.flow_rate
                    * self.config.extrusion_multiplier
                )

                lines.append(
                    self._extrude(
                        point.x,
                        point.y,
                        point.z,
                        extrusion,
                        feedrate,
                    )
                )

        lines.append("")
        return lines

    def _move(self, x: float, y: float, z: float, rapid: bool = False) -> str:
        """Generate a move command."""
        command = "G0" if rapid else "G1"
        self.current_position = [x, y, z]
        return f"{command} X{x:.3f} Y{y:.3f} Z{z:.3f}"

    def _move_z(self, z: float, rapid: bool = False) -> str:
        """Generate a Z-only move command."""
        command = "G0" if rapid else "G1"
        self.current_position[2] = z
        return f"{command} Z{z:.3f}"

    def _extrude(
        self, x: float, y: float, z: float, extrusion: float, feedrate: float
    ) -> str:
        """Generate an extrusion move command."""
        if self.config.use_relative_extrusion:
            e_value = extrusion
        else:
            self.current_extrusion += extrusion
            e_value = self.current_extrusion

        self.current_position = [x, y, z]
        self.current_feedrate = feedrate

        return f"G1 X{x:.3f} Y{y:.3f} Z{z:.3f} E{e_value:.5f} F{feedrate:.0f}"

    def _retract(self) -> str:
        """Generate a retraction command."""
        if self.config.use_relative_extrusion:
            e_value = -self.config.retract_distance
        else:
            self.current_extrusion -= self.config.retract_distance
            e_value = self.current_extrusion

        feedrate = self.config.retract_speed * 60
        return f"G1 E{e_value:.5f} F{feedrate:.0f}  ; Retract"

    def _unretract(self) -> str:
        """Generate an un-retraction command."""
        if self.config.use_relative_extrusion:
            e_value = self.config.retract_distance
        else:
            self.current_extrusion += self.config.retract_distance
            e_value = self.current_extrusion

        feedrate = self.config.retract_speed * 60
        return f"G1 E{e_value:.5f} F{feedrate:.0f}  ; Unretract"
