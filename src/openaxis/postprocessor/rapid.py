"""
ABB RAPID Post Processor â€” generates .mod files for ABB IRC5 controllers.

Outputs MoveL/MoveJ instructions with speed data, zone data, and tool/wobj references.
Supports speed data from v5 to v5000, zone data from fine to z200.
"""

from typing import Any, Dict, List, Optional

from .base import PostProcessorBase, PostProcessorConfig, PointData


# ABB speed data presets (mm/s)
SPEED_DATA = {
    5: 'v5', 10: 'v10', 20: 'v20', 30: 'v30', 40: 'v40', 50: 'v50',
    60: 'v60', 80: 'v80', 100: 'v100', 150: 'v150', 200: 'v200',
    300: 'v300', 400: 'v400', 500: 'v500', 600: 'v600', 800: 'v800',
    1000: 'v1000', 1500: 'v1500', 2000: 'v2000', 2500: 'v2500',
    3000: 'v3000', 4000: 'v4000', 5000: 'v5000',
}


def nearest_speed_data(speed_mm_s: float) -> str:
    """Find the nearest ABB speed data preset."""
    speeds = sorted(SPEED_DATA.keys())
    closest = min(speeds, key=lambda s: abs(s - speed_mm_s))
    return SPEED_DATA[closest]


class RAPIDPostProcessor(PostProcessorBase):
    """ABB RAPID post processor generating .mod files."""

    def __init__(self, config: Optional[PostProcessorConfig] = None):
        cfg = config or PostProcessorConfig(
            format_name='rapid',
            file_extension='.mod',
            comment_prefix='! ',
            speed_units='mm/s',
            zone_data='z5',
            tool_name='tool0',
            work_object='wobj0',
        )
        super().__init__(cfg)
        self._target_count = 0

    def comment(self, text: str) -> str:
        return f"  ! {text}"

    def _robtarget(self, pt: PointData) -> str:
        """Format a robtarget (position + quaternion)."""
        self._target_count += 1
        # Default orientation: tool Z pointing down (0, 0, -1, 0)
        return (
            f"[[{pt.x:.2f},{pt.y:.2f},{pt.z:.2f}],"
            f"[0,0,-1,0],"
            f"[0,0,0,0],"
            f"[9E+09,9E+09,9E+09,9E+09,9E+09,9E+09]]"
        )

    def header(self, toolpath_data: Dict[str, Any]) -> List[str]:
        name = self.config.program_name
        total_layers = toolpath_data.get('totalLayers', 0)
        total_points = toolpath_data.get('statistics', {}).get('totalPoints', 0)

        lines = [
            f"MODULE {name}",
            f"  ! Generated by OpenAxis Post Processor",
            f"  ! Layers: {total_layers}, Points: {total_points}",
            f"  ! Format: ABB RAPID",
            f"",
            f"  ! Tool and work object declarations",
            f"  PERS tooldata {self.config.tool_name}:=[TRUE,[[0,0,150],[1,0,0,0]],[5,[0,0,50],[1,0,0,0],0,0,0]];",
            f"  PERS wobjdata {self.config.work_object}:=[FALSE,TRUE,\"\",[[0,0,0],[1,0,0,0]],[[0,0,0],[1,0,0,0]]];",
            f"",
            f"  PROC main()",
            f"    ! Initialize",
            f"    ConfL\\Off;",
            f"    SingArea\\Wrist;",
        ]
        return lines

    def footer(self) -> List[str]:
        return [
            f"    ! Program complete",
            f"    MoveJ [[0,0,500],[0,0,-1,0],[0,0,0,0],[9E+09,9E+09,9E+09,9E+09,9E+09,9E+09]],v200,z50,{self.config.tool_name}\\WObj:={self.config.work_object};",
            f"  ENDPROC",
            f"ENDMODULE",
        ]

    def linear_move(self, pt: PointData) -> List[str]:
        speed = nearest_speed_data(pt.speed)
        zone = self.config.zone_data
        target = self._robtarget(pt)
        return [
            f"    MoveL {target},{speed},{zone},{self.config.tool_name}\\WObj:={self.config.work_object};"
        ]

    def rapid_move(self, pt: PointData) -> List[str]:
        speed = nearest_speed_data(min(pt.speed * 2, 5000))
        target = self._robtarget(pt)
        return [
            f"    MoveJ {target},{speed},z50,{self.config.tool_name}\\WObj:={self.config.work_object};"
        ]

    def process_on_code(self, pt: PointData) -> List[str]:
        return [
            f"    ! Process ON",
            f"    SetDO DO_ProcessOn, 1;",
            f"    WaitTime 0.1;",
        ]

    def process_off_code(self, pt: PointData) -> List[str]:
        return [
            f"    ! Process OFF",
            f"    SetDO DO_ProcessOn, 0;",
            f"    WaitTime 0.1;",
        ]

    def layer_change_code(self, layer: int) -> List[str]:
        return [
            f"",
            f"    ! ===== Layer {layer} =====",
        ]
