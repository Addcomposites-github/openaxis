"""
KUKA KRL Post Processor — generates .src files for KUKA KRC controllers.

Outputs LIN/PTP instructions with velocity, C_DIS/C_VEL blending parameters.
"""

from typing import Any, Dict, List, Optional

from .base import PostProcessorBase, PostProcessorConfig, PointData


class KRLPostProcessor(PostProcessorBase):
    """KUKA KRL post processor generating .src files."""

    def __init__(self, config: Optional[PostProcessorConfig] = None):
        cfg = config or PostProcessorConfig(
            format_name='krl',
            file_extension='.src',
            comment_prefix='; ',
            speed_units='mm/s',
            blending=5.0,
            tool_name='TOOL_DATA[1]',
            work_object='BASE_DATA[1]',
        )
        super().__init__(cfg)

    def comment(self, text: str) -> str:
        return f"  ; {text}"

    def _frame(self, pt: PointData) -> str:
        """Format a KUKA frame {X, Y, Z, A, B, C}.

        A, B, C are ZYX Euler angles (degrees) derived from the slicing plane normal.
        For planar Z-up slicing: A=0, B=180, C=0 (tool pointing straight down).

        HARDCODED CAVEAT: layer_normal = [0,0,1] for all planar slicing, giving
        B=180 always. For tilted/non-planar slicers A,B,C will vary per waypoint.
        KUKA $TOOL must also match the actual mounted tool — see header() below.

        Reference: KUKA System Variables Manual, $TOOL / FDAT data types.
        ZYX convention: A rotates about Z, B about Y, C about X.
        """
        a_deg, b_deg, c_deg = self.normal_to_zyx_euler(pt.layer_normal)
        return f"{{X {pt.x:.2f}, Y {pt.y:.2f}, Z {pt.z:.2f}, A {a_deg:.3f}, B {b_deg:.3f}, C {c_deg:.3f}}}"

    def header(self, toolpath_data: Dict[str, Any]) -> List[str]:
        name = self.config.program_name
        total_layers = toolpath_data.get('totalLayers', 0)
        total_points = toolpath_data.get('statistics', {}).get('totalPoints', 0)

        # TCP offset: [x,y,z,rx,ry,rz] meters + degrees ZYX, in flange frame.
        # KUKA $TOOL is a frame {X,Y,Z,A,B,C} where X,Y,Z are in mm and
        # A,B,C are ZYX Euler angles (degrees) — same convention as normal_to_zyx_euler.
        # HARDCODED CAVEAT: defaults to Z=150mm if tcpOffset absent.
        tcp = toolpath_data.get('tcpOffset', [0.0, 0.0, 0.15, 0.0, 0.0, 0.0])
        tx_mm = (tcp[0] if len(tcp) > 0 else 0.0) * 1000.0
        ty_mm = (tcp[1] if len(tcp) > 1 else 0.0) * 1000.0
        tz_mm = (tcp[2] if len(tcp) > 2 else 0.15) * 1000.0
        t_a   = tcp[5] if len(tcp) > 5 else 0.0   # rz → A
        t_b   = tcp[4] if len(tcp) > 4 else 0.0   # ry → B
        t_c   = tcp[3] if len(tcp) > 3 else 0.0   # rx → C

        tool_frame = f"{{X {tx_mm:.2f}, Y {ty_mm:.2f}, Z {tz_mm:.2f}, A {t_a:.3f}, B {t_b:.3f}, C {t_c:.3f}}}"

        lines = [
            f"&ACCESS RVP",
            f"&REL 1",
            f"&PARAM TEMPLATE = C:\\KRC\\Roboter\\Template\\vorgabe",
            f"&PARAM EDITMASK = *",
            f"DEF {name}()",
            f"  ; Generated by OpenAxis Post Processor",
            f"  ; Layers: {total_layers}, Points: {total_points}",
            f"  ; Format: KUKA KRL",
            f"  ; NOTE: $TOOL sourced from toolpath tcpOffset field.",
            f"  ;   Default Z={tz_mm:.1f}mm if tcpOffset absent. Verify before running.",
            f"",
            f"  ; Initialize",
            f"  ; $TOOL TCP frame in flange frame: position (mm) + ZYX Euler (deg)",
            f"  ; A=rz, B=ry, C=rx  (KUKA ZYX convention)",
            f"  {self.config.tool_name} = {tool_frame}",
            f"  $TOOL = {self.config.tool_name}",
            f"  $BASE = {self.config.work_object}",
            f"  $VEL.CP = {self.config.default_speed / 1000:.3f}  ; m/s",
            f"  $APO.CDIS = {self.config.blending:.1f}  ; mm blending",
            f"  BAS(#INITMOV, 0)",
        ]
        return lines

    def footer(self) -> List[str]:
        return [
            f"  ; Program complete",
            f"  PTP $H_POS",
            f"END",
        ]

    def linear_move(self, pt: PointData) -> List[str]:
        frame = self._frame(pt)
        vel = pt.speed / 1000  # mm/s to m/s
        blending = f" C_DIS" if self.config.blending > 0 else ""
        return [
            f"  $VEL.CP = {vel:.3f}",
            f"  LIN {frame}{blending}",
        ]

    def rapid_move(self, pt: PointData) -> List[str]:
        frame = self._frame(pt)
        return [
            f"  PTP {frame} C_DIS",
        ]

    def process_on_code(self, pt: PointData) -> List[str]:
        return [
            f"  ; Process ON",
            f"  $OUT[1] = TRUE",
            f"  WAIT SEC 0.1",
        ]

    def process_off_code(self, pt: PointData) -> List[str]:
        return [
            f"  ; Process OFF",
            f"  $OUT[1] = FALSE",
            f"  WAIT SEC 0.1",
        ]

    def layer_change_code(self, layer: int) -> List[str]:
        return [
            f"",
            f"  ; ===== Layer {layer} =====",
        ]
