"""
Fanuc LS Post Processor — generates .ls files for Fanuc controllers.

Outputs J/L instructions with CNT blending, speed in mm/sec.
"""

from typing import Any, Dict, List, Optional

from .base import PostProcessorBase, PostProcessorConfig, PointData


class FanucPostProcessor(PostProcessorBase):
    """Fanuc LS post processor generating .ls files."""

    def __init__(self, config: Optional[PostProcessorConfig] = None):
        cfg = config or PostProcessorConfig(
            format_name='fanuc',
            file_extension='.ls',
            comment_prefix='! ',
            speed_units='mm/sec',
            blending=50.0,  # CNT value 0-100
            tool_name='UTOOL[1]',
            work_object='UFRAME[1]',
        )
        super().__init__(cfg)
        self._line_num = 0
        self._point_num = 0

    def _next_line(self) -> int:
        self._line_num += 1
        return self._line_num

    def _next_point(self) -> int:
        self._point_num += 1
        return self._point_num

    def comment(self, text: str) -> str:
        return f"   ! {text} ;"

    def _position(self, pt: PointData) -> str:
        """Format a Fanuc position P[n:x,y,z,W,P,R].

        W, P, R are ZYX Euler angles (degrees) derived from the slicing plane normal.
        For planar Z-up slicing: W=0, P=180, R=0 (tool pointing straight down).

        HARDCODED CAVEAT: layer_normal = [0,0,1] for all planar slicing, giving
        P=180 always. For tilted/non-planar slicers W,P,R will vary per waypoint.
        UTOOL must also match the actual mounted tool — see header() below.

        Fanuc position format: P[n:x,y,z,W,P,R] where W=rz, P=ry, R=rx (ZYX Euler, deg).
        Reference: Fanuc SYSTEM R-30iB Operator Manual B-83284EN.
        """
        pn = self._next_point()
        w_deg, p_deg, r_deg = self.normal_to_zyx_euler(pt.layer_normal)
        return f"P[{pn}:{pt.x:.2f},{pt.y:.2f},{pt.z:.2f},{w_deg:.3f},{p_deg:.3f},{r_deg:.3f}]"

    def header(self, toolpath_data: Dict[str, Any]) -> List[str]:
        name = self.config.program_name
        total_layers = toolpath_data.get('totalLayers', 0)
        total_points = toolpath_data.get('statistics', {}).get('totalPoints', 0)

        # TCP offset: [x,y,z,rx,ry,rz] meters + degrees ZYX, in flange frame.
        # Fanuc UTOOL: {x,y,z,W,P,R} where x,y,z in mm, W=rz, P=ry, R=rx (ZYX, deg).
        # HARDCODED CAVEAT: defaults to Z=150mm if tcpOffset absent.
        tcp = toolpath_data.get('tcpOffset', [0.0, 0.0, 0.15, 0.0, 0.0, 0.0])
        tx_mm = (tcp[0] if len(tcp) > 0 else 0.0) * 1000.0
        ty_mm = (tcp[1] if len(tcp) > 1 else 0.0) * 1000.0
        tz_mm = (tcp[2] if len(tcp) > 2 else 0.15) * 1000.0
        t_w   = tcp[5] if len(tcp) > 5 else 0.0   # rz → W
        t_p   = tcp[4] if len(tcp) > 4 else 0.0   # ry → P
        t_r   = tcp[3] if len(tcp) > 3 else 0.0   # rx → R

        lines = [
            f"/PROG  {name}",
            f"/ATTR",
            f"OWNER\t\t= MNEDITOR;",
            f"COMMENT\t\t= \"OpenAxis Generated\";",
            f"PROG_SIZE\t= 0;",
            f"CREATE\t\t= DATE;",
            f"DEFAULT_GROUP\t= 1,*,*,*,*;",
            f"CONTROL_CODE\t= 00000000 00000000;",
            f"/MN",
            f"   ! Generated by OpenAxis Post Processor ;",
            f"   ! Layers: {total_layers}, Points: {total_points} ;",
            f"   ! Format: Fanuc LS ;",
            f"   ! NOTE: UTOOL sourced from toolpath tcpOffset field.",
            f"   !   Default Z={tz_mm:.1f}mm if tcpOffset absent. Verify before running. ;",
            f"   ! UTOOL format: X={tx_mm:.2f}mm Y={ty_mm:.2f}mm Z={tz_mm:.2f}mm"
            f" W={t_w:.3f}deg P={t_p:.3f}deg R={t_r:.3f}deg ;",
        ]
        self._line_num = 0
        self._point_num = 0

        # Setup — select tool and user frame
        ln = self._next_line()
        lines.append(f"   {ln}:  UTOOL_NUM={self.config.tool_name.replace('UTOOL[','').replace(']','')} ;")
        ln = self._next_line()
        lines.append(f"   {ln}:  UFRAME_NUM={self.config.work_object.replace('UFRAME[','').replace(']','')} ;")

        return lines

    def footer(self) -> List[str]:
        ln = self._next_line()
        lines = [
            f"   ! Program complete ;",
            f"   {ln}:  J P[1] 50% FINE ;",
            f"/POS",
            f"/END",
        ]
        return lines

    def linear_move(self, pt: PointData) -> List[str]:
        ln = self._next_line()
        speed = pt.speed  # mm/sec
        cnt = int(self.config.blending)
        pos = self._position(pt)
        return [
            f"   {ln}:L {pos} {speed:.0f}mm/sec CNT{cnt} ;",
        ]

    def rapid_move(self, pt: PointData) -> List[str]:
        ln = self._next_line()
        pos = self._position(pt)
        return [
            f"   {ln}:J {pos} 100% FINE ;",
        ]

    def process_on_code(self, pt: PointData) -> List[str]:
        ln = self._next_line()
        return [
            f"   ! Process ON ;",
            f"   {ln}:  DO[1:ProcessOn]=ON ;",
        ]

    def process_off_code(self, pt: PointData) -> List[str]:
        ln = self._next_line()
        return [
            f"   ! Process OFF ;",
            f"   {ln}:  DO[1:ProcessOn]=OFF ;",
        ]

    def layer_change_code(self, layer: int) -> List[str]:
        return [
            f"",
            f"   ! ===== Layer {layer} =====",
        ]
